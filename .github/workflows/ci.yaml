name: CI
run-name: "${{ github.event_name == 'workflow_dispatch' && format('CI: {0}', github.ref_name) || '' }}"

on:
  push:
    branches:
      - main
      - 'release/*'
  workflow_dispatch:
    inputs:
      build_and_push:
        description: "Build and Push Docker"
        default: false
        type: boolean
      deploy_container:
        description: "Deploy Container Instance"
        type: boolean
        required: false
      image_tag:
        description: "Deploy Container Instance - Image Tag. A specific version/build of the image."
        type: string
        required: false
      deploy_function:
        description: "Deploy Function App"
        type: boolean
        required: false
      target:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - production
          - staging
          - dev
permissions:
  id-token: write # This is required for requesting the JWT
  contents: read # This is required for actions/checkout

env:
  ENVIRONMENT: ${{ vars.ENVIRONMENT  }}
  LOCATION: ${{ vars.LOCATION }}
  MODEL_NAME: ${{ vars.MODEL_NAME }}
  MODEL_VERSION: ${{ vars.MODEL_VERSION }}
  KEY_VAULT_NAME: ${{ vars.KEY_VAULT_NAME }}
  CACHE_VERSION: 1
  PRE_COMMIT_CACHE: ~/.cache/pre-commit
  PYTHON_VERSION: "3.12"

jobs:
  info:
    name: Collect information & changes data
    runs-on: &runs-on-ubuntu ubuntu-24.04
    outputs:
      channel: ${{ steps.version.outputs.channel }}
      pre-commit_cache_key: ${{ steps.generate_pre-commit_cache_key.outputs.key }}
      python_chache_key: ${{ steps.generate_python_cache_key.outputs.key }}
    steps:
      - &checkout
        name: Check out code from GitHub
        uses: actions/checkout@v5
      - shell: bash
        id: version
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          WORKFLOW_TARGET: ${{ github.event.inputs.target }}
        run: |

          if [[ "$EVENT_NAME" == "workflow_dispatch" && -n "$WORKFLOW_TARGET" ]]; then
            TARGET="$WORKFLOW_TARGET"
            echo "Using workflow dispatch target: $TARGET"
          else
            # Set environment based on branch
            case "$REF_NAME" in
              main|master)
                TARGET="production"
                ;;
              staging)
                TARGET="staging"
                ;;
              develop)
                TARGET="dev"
                ;;
              *)
                TARGET="dev"
                ;;
            esac
            echo "Detected branch: $REF_NAME, setting target: $TARGET"
          fi

          echo "channel=staging" >> $GITHUB_OUTPUT

      - name: Generate partial pre-commit restore key
        id: generate_pre-commit_cache_key
        run: >-
          echo "key=pre-commit-${{ env.CACHE_VERSION }}-${{
            hashFiles('.pre-commit-config.yaml') }}"  >> $GITHUB_OUTPUT
      - name: Generate partial Python venv restore key
        id: generate_python_cache_key
        run: >-
          echo "key=venv-${{ env.CACHE_VERSION }}-${{
            hashFiles('requirements.txt') }}-${{
            hashFiles('requirements_dev.txt') }}" >> $GITHUB_OUTPUT
  pre-commit:
    name: Prepare pre-commit base
    runs-on: *runs-on-ubuntu
    needs: [info]
    steps:
      - *checkout
      - &setup-python-default
        name: Set up Python ${{ env.PYTHON_VERSION }}
        id: python
        uses: actions/setup-python@v6.1.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          check-latest: true
      - name: Restore base Python virtual environment
        id: cache-venv
        uses: &actions-cache actions/cache@v4.3.0
        with:
          path: venv
          key: &key-pre-commit-venv >-
            ${{ runner.os }}-${{ steps.python.outputs.python-version }}-venv-${{
              needs.info.outputs.pre-commit_cache_key }}
      - name: Create Python virtual environment
        if: steps.cache-venv.outputs.cache-hit != 'true'
        run: |
          python -m venv venv
          . venv/bin/activate
          python --version
          pip install -r requirements_dev.txt
      - name: Restore pre-commit environment from cache
        id: cache-precommit
        uses: *actions-cache
        with:
          path: ${{ env.PRE_COMMIT_CACHE }}
          lookup-only: true
          key: &key-pre-commit-env >-
            ${{ runner.os }}-${{ steps.python.outputs.python-version }}-${{
              needs.info.outputs.pre-commit_cache_key }}
      - name: Install pre-commit dependencies
        if: steps.cache-precommit.outputs.cache-hit != 'true'
        run: |
          . venv/bin/activate
          pre-commit install-hooks
  lint:
    name: Lint Code
    runs-on: *runs-on-ubuntu
    needs:
      - info
      - pre-commit
    steps:
      - *checkout
      - *setup-python-default
      - &cache-restore-pre-commit-venv
        name: Restore base Python virtual environment
        id: cache-venv
        uses: &actions-cache-restore actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: venv
          fail-on-cache-miss: true
          key: *key-pre-commit-venv
      - &cache-restore-pre-commit-env
        name: Restore pre-commit environment from cache
        id: cache-precommit
        uses: *actions-cache-restore
        with:
          path: ${{ env.PRE_COMMIT_CACHE }}
          fail-on-cache-miss: true
          key: *key-pre-commit-env

      - name: Run isort
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual isort --all-files --show-diff-on-failure

      - name: Run ruff-format
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual ruff-format --all-files --show-diff-on-failure
        env:
          RUFF_OUTPUT_FORMAT: github

      - name: Run ruff-check
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual ruff-check --all-files --show-diff-on-failure
        env:
          RUFF_OUTPUT_FORMAT: github

      - name: Run yamllint
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual yamllint --all-files --show-diff-on-failure

      - name: Run check-docstring-first
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual check-docstring-first --all-files --show-diff-on-failure

      - name: Run check-shebang-scripts-are-executable
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual check-shebang-scripts-are-executable --all-files --show-diff-on-failure

      - name: Run check-executables-have-shebangs
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual check-executables-have-shebangs --all-files --show-diff-on-failure

      - name: Run check-json
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual check-json --all-files --show-diff-on-failure

      - name: end-of-file-fixer
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual end-of-file-fixer --all-files --show-diff-on-failure

      - name: fix-byte-order-marker
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual fix-byte-order-marker --all-files --show-diff-on-failure

      - name: mixed-line-ending
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual mixed-line-ending --all-files --show-diff-on-failure

      - name: trailing-whitespace
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual trailing-whitespace --all-files --show-diff-on-failure

      - name: Run codespell
        run: |
          . venv/bin/activate
          pre-commit run --hook-stage manual codespell --all-files --show-diff-on-failure

      - name: Shell check
        run: |
          shellcheck -x ${{ github.workspace }}/script/*.sh

  build_and_push_docker_image:
    needs: [info, lint]
    runs-on: *runs-on-ubuntu
    environment: ${{ needs.info.outputs.channel }}
    outputs:
      build_tag: ${{ steps.build-docker-image.outputs.build_tag }}
    if: |
      !failure() && !cancelled() &&
      (
        (github.event_name != 'workflow_dispatch' && github.event.inputs.build_and_push == 'true')
        ||
        (github.event_name == 'push')
      )
    steps:
      - *checkout

      - name: OIDC Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.CICD_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.SUBSCRIPTION_ID }}

      - name: Fetch Artifact
        run: |
          ./script/devops.sh fetch_artifact \
            --account-name "${{ vars.ARTIFACT_STORAGE_ACCOUNT }}" \
            --account-key "${{ secrets.ARTIFACT_STORAGE_KEY }}" \

      - name: Build docker image
        id: build-docker-image
        run: |
          build_tag=$(./script/devops.sh build_image \
            --channel dev)

          echo "BUILD_TAG=${build_tag}" >> $GITHUB_ENV
          echo "build_tag=${build_tag}" >> $GITHUB_OUTPUT
        env:
          APP_INSTALLER_FILE: ${{ vars.APP_INSTALLER_FILE }}
          APP_FILE: ${{ vars.APP_FILE }}
          APP_SETUP_ARGS: ${{ vars.APP_SETUP_ARGS }}
          APP_ALIAS: ${{ vars.APP_ALIAS }}

      - name: Publish Image
        run: |
          build_tag="${{ env.BUILD_TAG }}"

          ./script/devops.sh publish_image \
            --tag "$build_tag" \
            --channel dev
  deploy_container_instance:
    name: Deploy Container Instance
    needs: [info, build_and_push_docker_image]
    runs-on: *runs-on-ubuntu
    environment: ${{ needs.info.outputs.channel }}
    if: |
      !failure() && !cancelled() &&
      (
        (github.event_name != 'workflow_dispatch' && github.event.inputs.deploy_container == 'true')
        ||
        (github.event_name == 'push')
      )
    steps:
      - *checkout

      - name: OIDC Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.CICD_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.SUBSCRIPTION_ID }}

      - name: Deploy Container Instance
        id: task-deploy-container
        run: |
          ./script/devops.sh deploy_container_instance \
            --tag "${{ github.event_name == 'workflow_dispatch' && github.event.inputs.image_tag || needs.build_and_push_docker_image.outputs.build_tag }}"
        env:
          APP_LOG_FILE: ${{ vars.APP_LOG_FILE }}

  deploy_function_app:
    name: Deploy Function App
    needs: [info, lint]
    runs-on: *runs-on-ubuntu
    environment: ${{ needs.info.outputs.channel }}
    if: |
      !failure() && !cancelled() &&
      (
        (github.event_name != 'workflow_dispatch' && github.event.inputs.deploy_function == 'true')
        ||
        (github.event_name == 'push')
      )
    steps:
      - *checkout

      - name: OIDC Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.CICD_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.SUBSCRIPTION_ID }}

      - name: Deploy Function App
        id: task-deploy-function
        run: |
          ./script/devops.sh deploy_function_app
        env:
          SUBSCRIPTION_ID: ${{ secrets.SUBSCRIPTION_ID }}
